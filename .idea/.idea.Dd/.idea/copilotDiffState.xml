<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dd.Domain.Test/Reservation/Entities/BlockedTimeTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dd.Domain.Test/Reservation/Entities/BlockedTimeTests.cs" />
              <option name="originalContent" value="using Dd.Domain.Reservation.Entities;&#10;using Dd.Domain.Reservation.Enums;&#10;&#10;namespace Dd.Domain.Test.Reservation.Entities;&#10;&#10;public class BlockedTimeTests {&#10;    private readonly DateOnly _date610 = new DateOnly(2024, 6, 10);&#10;    private readonly DateOnly _date615 = new DateOnly(2024, 6, 15);&#10;    private readonly DateOnly _date620 = new DateOnly(2024, 6, 20);&#10;    private readonly DateOnly _date621 = new DateOnly(2024, 6, 21);&#10;        &#10;    // constructor tests&#10;    [Fact]&#10;    public void Constructor_ShouldInitializeProperties_WhenValidParametersAreProvided() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));&#10;        const BlockedTimeType blockedTimeType = BlockedTimeType.Vacation;&#10;&#10;        var blockedTime = new BlockedTime(blockedTimeType);&#10;        &#10;        // Assert&#10;        Assert.Equal(TimeOnly.MinValue, blockedTime.StartTime);&#10;        Assert.Equal(TimeOnly.MaxValue, blockedTime.EndTime);&#10;        Assert.Null(blockedTime.StartDate);&#10;        Assert.Null(blockedTime.EndDate);&#10;        Assert.False(blockedTime.BlocksAllPhysicians);&#10;        Assert.Equal(blockedTimeType, blockedTime.BlockedTimeType);&#10;        Assert.Equal(RecurrenceType.Daily, blockedTime.RecurrenceType);&#10;        Assert.Empty(blockedTime.RecurrenceDays);&#10;        Assert.Equal(1, blockedTime.RecurrenceInterval);&#10;&#10;        // Act&#10;        blockedTime = new BlockedTime(blockedTimeType, startTime, endTime);&#10;&#10;        // Assert&#10;        Assert.Equal(startTime, blockedTime.StartTime);&#10;        Assert.Equal(endTime, blockedTime.EndTime);&#10;        &#10;        blockedTime = new BlockedTime(blockedTimeType, startTime, endTime, startDate, endDate);&#10;        &#10;        Assert.Equal(startDate, blockedTime.StartDate);&#10;        Assert.Equal(endDate, blockedTime.EndDate);&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_ShouldThrowArgumentExceptionWhenEndTimeComesBeforeStartTime() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(17, 0);&#10;        var endTime = new TimeOnly(9, 0);&#10;        const BlockedTimeType blockedTimeType = BlockedTimeType.Vacation;&#10;&#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; new BlockedTime(blockedTimeType, startTime, endTime));&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_ShouldThrowArgumentExceptionWhenEndTimeComesAfterEndTime() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(0));&#10;        const BlockedTimeType blockedTimeType = BlockedTimeType.Vacation;&#10;&#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; new BlockedTime(blockedTimeType, startTime, endTime, startDate, endDate));&#10;    }&#10;    &#10;    // BlocksAll tests&#10;    [Fact]&#10;    public void BlocksAll_ShouldSetBlocksAllPhysiciansToTrue() {&#10;        // Arrange&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, new TimeOnly(9, 0), new TimeOnly(17, 0));&#10;        // Act&#10;        blockedTime.BlocksAll();&#10;        // Assert&#10;        Assert.True(blockedTime.BlocksAllPhysicians);&#10;    }&#10;    &#10;    // RecurWeekly tests&#10;    &#10;    [Fact]&#10;    public void RecurWeekly_ShouldRemoveDuplicateDays_WhenCalledWithDuplicateDays() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startTime, endTime, startDate);&#10;        List&lt;DayOfWeek&gt; daysOfWeek = [DayOfWeek.Monday, DayOfWeek.Monday, DayOfWeek.Wednesday];&#10;&#10;        // Act&#10;        blockedTime.RecurWeekly(daysOfWeek);&#10;&#10;        // Assert&#10;        Assert.Equal(RecurrenceType.Weekly, blockedTime.RecurrenceType);&#10;        Assert.Equal(daysOfWeek.Distinct().ToList(), blockedTime.RecurrenceDays);&#10;    }&#10;    &#10;    [Fact]&#10;    public void RecurWeekly_ShouldSetRecurrenceProperties_WhenCalledWithValidDaysAndInterval() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startTime, endTime, startDate);&#10;        List&lt;DayOfWeek&gt; daysOfWeek = [DayOfWeek.Monday, DayOfWeek.Wednesday];&#10;&#10;        // Act&#10;        blockedTime.RecurWeekly(daysOfWeek, 2);&#10;&#10;        // Assert&#10;        Assert.Equal(RecurrenceType.Weekly, blockedTime.RecurrenceType);&#10;        Assert.Equal(2, blockedTime.RecurrenceInterval);&#10;        Assert.Equal(daysOfWeek, blockedTime.RecurrenceDays);&#10;    }&#10;&#10;    [Fact]&#10;    public void RecurWeekly_ShouldThrowArgumentOutOfRangeException_WhenIntervalIsNotPositive() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startTime, endTime, startDate);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; blockedTime.RecurWeekly([DayOfWeek.Monday], 0));&#10;        Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; blockedTime.RecurWeekly([DayOfWeek.Monday], -1));&#10;    }&#10;&#10;    [Fact]&#10;    public void RecurWeekly_ShouldThrowArgumentException_WhenDaysOfWeekIsNullOrEmpty() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startTime, endTime, startDate);&#10;&#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; blockedTime.RecurWeekly(null!));&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; blockedTime.RecurWeekly([]));&#10;    }&#10;    &#10;    [Fact]&#10;    public void UpdateRecurrenceInterval_ShouldUpdateInterval_WhenCalledWithValidInterval() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var blockedTime = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime);&#10;        &#10;        // Act&#10;        blockedTime.UpdateRecurrenceInterval(3);&#10;        &#10;        // Assert&#10;        Assert.Equal(3, blockedTime.RecurrenceInterval);&#10;    }&#10;    &#10;    [Fact]&#10;    public void UpdateRecurrenceInterval_ShouldThrowArgumentOutOfRangeException_WhenIntervalIsNotPositive() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime, startDate);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; blockedTime.UpdateRecurrenceInterval(0));&#10;        Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; blockedTime.UpdateRecurrenceInterval(-1));&#10;    }&#10;    &#10;    // RecurDaily tests&#10;    [Fact]&#10;    public void RecurDaily_ShouldSetRecurrenceProperties_WhenCalledWithValidInterval() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var blockedTime = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime);&#10;        &#10;        // Act&#10;        blockedTime.RecurDaily(2);&#10;        &#10;        // Assert&#10;        Assert.Equal(RecurrenceType.Daily, blockedTime.RecurrenceType);&#10;        Assert.Equal(2, blockedTime.RecurrenceInterval);&#10;    }&#10;&#10;    [Fact]&#10;    public void RecurDaily_ShouldThrowArgumentOutOfRangeException_WhenIntervalIsNotPositive() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var blockedTime = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; blockedTime.RecurDaily(0));&#10;        Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; blockedTime.RecurDaily(-1));&#10;    }&#10;    &#10;    // IsWholeDayBlocked tests&#10;&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnFalse_WhenDateIsBeforeStartDate() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow));&#10;&#10;        // Assert&#10;        Assert.False(isBlocked);&#10;        &#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var blockedTimeWithTime = new BlockedTime(BlockedTimeType.Vacation, startTime, endTime, startDate, endDate);&#10;        &#10;        // Act&#10;        isBlocked = blockedTimeWithTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow));&#10;        &#10;        // Assert&#10;        Assert.False(isBlocked);&#10;    }&#10;&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnFalse_WhenDateIsAfterEndDate() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow.AddDays(3)));&#10;&#10;        // Assert&#10;        Assert.False(isBlocked);&#10;        &#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var blockedTimeWithTime = new BlockedTime(BlockedTimeType.Vacation, startTime, endTime, startDate, endDate);&#10;        &#10;        // Act&#10;        isBlocked = blockedTimeWithTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow.AddDays(3)));&#10;        &#10;        // Assert&#10;        Assert.False(isBlocked);&#10;    }&#10;    &#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnFalse_WhenStartTimeAndEndTimeAreSet() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startTime, endTime, startDate, endDate);&#10;        &#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1)));&#10;        &#10;        // Assert&#10;        Assert.False(isBlocked);&#10;    }&#10;    &#10;    // IsWholeDayBlocked Daily recurrence tests&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenDateIsStartDate() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(startDate);&#10;&#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;    &#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenDateIsEndDate() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;        &#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(endDate);&#10;        &#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;    &#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenDateIsWithInBlockedTime() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(3));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2)));&#10;&#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenStartAndEndDatesNotSpecified() {&#10;        // Arrange&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow));&#10;&#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;    &#10;    // IsWholeDayBlocked Weekly recurrence tests&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenDateIsStartDateWeekly() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(4));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;        blockedTime.RecurWeekly([startDate.DayOfWeek, endDate.DayOfWeek]);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(startDate);&#10;&#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenDateIsEndDateWeekly() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(4));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;        blockedTime.RecurWeekly([startDate.DayOfWeek, endDate.DayOfWeek]);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(endDate);&#10;&#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenDateIsWithInBlockedTimeWeekly() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var date = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(4));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;        blockedTime.RecurWeekly([date.DayOfWeek]);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(date);&#10;&#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnFalse_WhenDateIsWithInRageButDayIsNotInDaysList() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var date = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(3));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(4));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;        blockedTime.RecurWeekly([startDate.DayOfWeek, endDate.DayOfWeek]);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(date);&#10;&#10;        // Assert&#10;        Assert.False(isBlocked);&#10;    }&#10;&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenStartDateAndEndDateAreNotSpecifiedAndDayOfWeekMatches() {&#10;        // Arrange&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation);&#10;        blockedTime.RecurWeekly([DateOnly.FromDateTime(DateTime.UtcNow).DayOfWeek]);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow));&#10;&#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;    &#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnFalse_WhenStartDateAndEndDateAreNotSpecifiedButDayOfWeekDoesNotMatch() {&#10;        // Arrange&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation);&#10;        var day1 = DateOnly.FromDateTime(DateTime.UtcNow);&#10;        var day2 = day1.AddDays(1);&#10;        var day3 = day1.AddDays(2);&#10;        blockedTime.RecurWeekly([day1.DayOfWeek, day2.DayOfWeek]);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(day3);&#10;&#10;        // Assert&#10;        Assert.False(isBlocked);&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ReturnsFalse_WhenDateIsBeforeStartDate() {&#10;        var dateToCheck = new DateOnly(2024, 6, 9);&#10;        var startTimeToCheck = new TimeOnly(8, 0);&#10;        var endTimeToCheck = new TimeOnly(9, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startDate: _date610, endDate: _date620);&#10;        Assert.False(blocked.IsBlocked(dateToCheck, startTimeToCheck, endTimeToCheck));&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ReturnsFalse_WhenDateIsAfterEndDate() {&#10;        var startTimeToCheck = new TimeOnly(8, 0);&#10;        var endTimeToCheck = new TimeOnly(9, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startDate: _date610, endDate: _date620);&#10;        Assert.False(blocked.IsBlocked(_date621, startTimeToCheck, endTimeToCheck));&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ReturnsFalse_WhenTimeDoesNotOverlap() {&#10;        var startTime = new TimeOnly(10, 0);&#10;        var endTime = new TimeOnly(12, 0);&#10;        var startTimeToCheck = new TimeOnly(8, 0);&#10;        var endTimeToCheck = new TimeOnly(9, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime, _date615, _date615);&#10;        Assert.False(blocked.IsBlocked(_date615, startTimeToCheck, endTimeToCheck));&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ReturnsTrue_WhenTimeOverlaps() {&#10;        var startTime = new TimeOnly(10, 0);&#10;        var endTime = new TimeOnly(12, 0);&#10;        var startTimeToCheck = new TimeOnly(11, 0);&#10;        var endTimeToCheck = new TimeOnly(13, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime, _date615, _date615);&#10;        Assert.True(blocked.IsBlocked(_date615, startTimeToCheck, endTimeToCheck));&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ReturnsTrue_ForDailyRecurrence() {&#10;        var startTime = new TimeOnly(8, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startTimeToCheck = new TimeOnly(9, 0);&#10;        var endTimeToCheck = new TimeOnly(10, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime, _date610, _date620);&#10;        Assert.True(blocked.IsBlocked(_date615, startTimeToCheck, endTimeToCheck));&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ReturnsFalse_ForWeeklyRecurrence_DayNotIncluded() {&#10;        var startTime = new TimeOnly(8, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startTimeToCheck = new TimeOnly(9, 0);&#10;        var endTimeToCheck = new TimeOnly(10, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime, _date610, _date620);&#10;        blocked.RecurWeekly([DayOfWeek.Monday]);&#10;        Assert.False(blocked.IsBlocked(new DateOnly(2024, 6, 12), startTimeToCheck, endTimeToCheck)); // Wednesday&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ReturnsTrue_ForWeeklyRecurrence_DayIncluded() {&#10;        var startTime = new TimeOnly(8, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startTimeToCheck = new TimeOnly(9, 0);&#10;        var endTimeToCheck = new TimeOnly(10, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime, _date610, _date620);&#10;        blocked.RecurWeekly([DayOfWeek.Wednesday]);&#10;        Assert.True(blocked.IsBlocked(new DateOnly(2024, 6, 12), startTimeToCheck, endTimeToCheck)); // Wednesday&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ThrowsArgumentException_WhenStartTimeIsAfterEndTime() {&#10;        var startTime = new TimeOnly(8, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startTimeToCheck = new TimeOnly(12, 0);&#10;        var endTimeToCheck = new TimeOnly(10, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime, _date610, _date620);&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt;&#10;            blocked.IsBlocked(new DateOnly(2024, 6, 12), startTimeToCheck, endTimeToCheck));&#10;    }&#10;}" />
              <option name="updatedContent" value="using Dd.Domain.Reservation.Entities;&#10;using Dd.Domain.Reservation.Enums;&#10;&#10;namespace Dd.Domain.Test.Reservation.Entities;&#10;&#10;public class BlockedTimeTests {&#10;    private readonly DateOnly _date610 = new DateOnly(2024, 6, 10);&#10;    private readonly DateOnly _date615 = new DateOnly(2024, 6, 15);&#10;    private readonly DateOnly _date620 = new DateOnly(2024, 6, 20);&#10;    private readonly DateOnly _date621 = new DateOnly(2024, 6, 21);&#10;        &#10;    // constructor tests&#10;    [Fact]&#10;    public void Constructor_ShouldInitializeProperties_WhenValidParametersAreProvided() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));&#10;        const BlockedTimeType blockedTimeType = BlockedTimeType.Vacation;&#10;&#10;        var blockedTime = new BlockedTime(blockedTimeType);&#10;        &#10;        // Assert&#10;        Assert.Equal(TimeOnly.MinValue, blockedTime.StartTime);&#10;        Assert.Equal(TimeOnly.MaxValue, blockedTime.EndTime);&#10;        Assert.Null(blockedTime.StartDate);&#10;        Assert.Null(blockedTime.EndDate);&#10;        Assert.False(blockedTime.BlocksAllPhysicians);&#10;        Assert.Equal(blockedTimeType, blockedTime.BlockedTimeType);&#10;        Assert.Equal(RecurrenceType.Daily, blockedTime.RecurrenceType);&#10;        Assert.Empty(blockedTime.RecurrenceDays);&#10;        Assert.Equal(1, blockedTime.RecurrenceInterval);&#10;&#10;        // Act&#10;        blockedTime = new BlockedTime(blockedTimeType, startTime, endTime);&#10;&#10;        // Assert&#10;        Assert.Equal(startTime, blockedTime.StartTime);&#10;        Assert.Equal(endTime, blockedTime.EndTime);&#10;        &#10;        blockedTime = new BlockedTime(blockedTimeType, startTime, endTime, startDate, endDate);&#10;        &#10;        Assert.Equal(startDate, blockedTime.StartDate);&#10;        Assert.Equal(endDate, blockedTime.EndDate);&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_ShouldThrowArgumentExceptionWhenEndTimeComesBeforeStartTime() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(17, 0);&#10;        var endTime = new TimeOnly(9, 0);&#10;        const BlockedTimeType blockedTimeType = BlockedTimeType.Vacation;&#10;&#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; new BlockedTime(blockedTimeType, startTime, endTime));&#10;    }&#10;&#10;    [Fact]&#10;    public void Constructor_ShouldThrowArgumentExceptionWhenEndTimeComesAfterEndTime() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(0));&#10;        const BlockedTimeType blockedTimeType = BlockedTimeType.Vacation;&#10;&#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; new BlockedTime(blockedTimeType, startTime, endTime, startDate, endDate));&#10;    }&#10;    &#10;    // BlocksAll tests&#10;    [Fact]&#10;    public void BlocksAll_ShouldSetBlocksAllPhysiciansToTrue() {&#10;        // Arrange&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, new TimeOnly(9, 0), new TimeOnly(17, 0));&#10;        // Act&#10;        blockedTime.BlocksAll();&#10;        // Assert&#10;        Assert.True(blockedTime.BlocksAllPhysicians);&#10;    }&#10;    &#10;    // RecurWeekly tests&#10;    &#10;    [Fact]&#10;    public void RecurWeekly_ShouldRemoveDuplicateDays_WhenCalledWithDuplicateDays() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startTime, endTime, startDate);&#10;        List&lt;DayOfWeek&gt; daysOfWeek = [DayOfWeek.Monday, DayOfWeek.Monday, DayOfWeek.Wednesday];&#10;&#10;        // Act&#10;        blockedTime.RecurWeekly(daysOfWeek);&#10;&#10;        // Assert&#10;        Assert.Equal(RecurrenceType.Weekly, blockedTime.RecurrenceType);&#10;        Assert.Equal(daysOfWeek.Distinct().ToList(), blockedTime.RecurrenceDays);&#10;    }&#10;    &#10;    [Fact]&#10;    public void RecurWeekly_ShouldSetRecurrenceProperties_WhenCalledWithValidDaysAndInterval() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startTime, endTime, startDate);&#10;        List&lt;DayOfWeek&gt; daysOfWeek = [DayOfWeek.Monday, DayOfWeek.Wednesday];&#10;&#10;        // Act&#10;        blockedTime.RecurWeekly(daysOfWeek, 2);&#10;&#10;        // Assert&#10;        Assert.Equal(RecurrenceType.Weekly, blockedTime.RecurrenceType);&#10;        Assert.Equal(2, blockedTime.RecurrenceInterval);&#10;        Assert.Equal(daysOfWeek, blockedTime.RecurrenceDays);&#10;    }&#10;&#10;    [Fact]&#10;    public void RecurWeekly_ShouldThrowArgumentOutOfRangeException_WhenIntervalIsNotPositive() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startTime, endTime, startDate);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; blockedTime.RecurWeekly([DayOfWeek.Monday], 0));&#10;        Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; blockedTime.RecurWeekly([DayOfWeek.Monday], -1));&#10;    }&#10;&#10;    [Fact]&#10;    public void RecurWeekly_ShouldThrowArgumentException_WhenDaysOfWeekIsNullOrEmpty() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startTime, endTime, startDate);&#10;&#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; blockedTime.RecurWeekly(null!));&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; blockedTime.RecurWeekly([]));&#10;    }&#10;    &#10;    [Fact]&#10;    public void UpdateRecurrenceInterval_ShouldUpdateInterval_WhenCalledWithValidInterval() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var blockedTime = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime);&#10;        &#10;        // Act&#10;        blockedTime.UpdateRecurrenceInterval(3);&#10;        &#10;        // Assert&#10;        Assert.Equal(3, blockedTime.RecurrenceInterval);&#10;    }&#10;    &#10;    [Fact]&#10;    public void UpdateRecurrenceInterval_ShouldThrowArgumentOutOfRangeException_WhenIntervalIsNotPositive() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime, startDate);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; blockedTime.UpdateRecurrenceInterval(0));&#10;        Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; blockedTime.UpdateRecurrenceInterval(-1));&#10;    }&#10;    &#10;    // RecurDaily tests&#10;    [Fact]&#10;    public void RecurDaily_ShouldSetRecurrenceProperties_WhenCalledWithValidInterval() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var blockedTime = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime);&#10;        &#10;        // Act&#10;        blockedTime.RecurDaily(2);&#10;        &#10;        // Assert&#10;        Assert.Equal(RecurrenceType.Daily, blockedTime.RecurrenceType);&#10;        Assert.Equal(2, blockedTime.RecurrenceInterval);&#10;    }&#10;&#10;    [Fact]&#10;    public void RecurDaily_ShouldThrowArgumentOutOfRangeException_WhenIntervalIsNotPositive() {&#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var blockedTime = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime);&#10;        &#10;        // Act &amp; Assert&#10;        Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; blockedTime.RecurDaily(0));&#10;        Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; blockedTime.RecurDaily(-1));&#10;    }&#10;    &#10;    // IsWholeDayBlocked tests&#10;&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnFalse_WhenDateIsBeforeStartDate() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow));&#10;&#10;        // Assert&#10;        Assert.False(isBlocked);&#10;        &#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var blockedTimeWithTime = new BlockedTime(BlockedTimeType.Vacation, startTime, endTime, startDate, endDate);&#10;        &#10;        // Act&#10;        isBlocked = blockedTimeWithTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow));&#10;        &#10;        // Assert&#10;        Assert.False(isBlocked);&#10;    }&#10;&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnFalse_WhenDateIsAfterEndDate() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow.AddDays(3)));&#10;&#10;        // Assert&#10;        Assert.False(isBlocked);&#10;        &#10;        // Arrange&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var blockedTimeWithTime = new BlockedTime(BlockedTimeType.Vacation, startTime, endTime, startDate, endDate);&#10;        &#10;        // Act&#10;        isBlocked = blockedTimeWithTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow.AddDays(3)));&#10;        &#10;        // Assert&#10;        Assert.False(isBlocked);&#10;    }&#10;    &#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnFalse_WhenStartTimeAndEndTimeAreSet() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));&#10;        var startTime = new TimeOnly(9, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startTime, endTime, startDate, endDate);&#10;        &#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1)));&#10;        &#10;        // Assert&#10;        Assert.False(isBlocked);&#10;    }&#10;    &#10;    // IsWholeDayBlocked Daily recurrence tests&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenDateIsStartDate() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(startDate);&#10;&#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;    &#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenDateIsEndDate() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;        &#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(endDate);&#10;        &#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;    &#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenDateIsWithInBlockedTime() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(3));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2)));&#10;&#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenStartAndEndDatesNotSpecified() {&#10;        // Arrange&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow));&#10;&#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;    &#10;    // IsWholeDayBlocked Weekly recurrence tests&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenDateIsStartDateWeekly() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(4));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;        blockedTime.RecurWeekly([startDate.DayOfWeek, endDate.DayOfWeek]);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(startDate);&#10;&#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenDateIsEndDateWeekly() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(4));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;        blockedTime.RecurWeekly([startDate.DayOfWeek, endDate.DayOfWeek]);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(endDate);&#10;&#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenDateIsWithInBlockedTimeWeekly() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var date = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(4));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;        blockedTime.RecurWeekly([date.DayOfWeek]);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(date);&#10;&#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnFalse_WhenDateIsWithInRageButDayIsNotInDaysList() {&#10;        // Arrange&#10;        var startDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));&#10;        var date = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(3));&#10;        var endDate = DateOnly.FromDateTime(DateTime.UtcNow.AddDays(4));&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation, startDate: startDate, endDate: endDate);&#10;        blockedTime.RecurWeekly([startDate.DayOfWeek, endDate.DayOfWeek]);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(date);&#10;&#10;        // Assert&#10;        Assert.False(isBlocked);&#10;    }&#10;&#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnTrue_WhenStartDateAndEndDateAreNotSpecifiedAndDayOfWeekMatches() {&#10;        // Arrange&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation);&#10;        blockedTime.RecurWeekly([DateOnly.FromDateTime(DateTime.UtcNow).DayOfWeek]);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(DateOnly.FromDateTime(DateTime.UtcNow));&#10;&#10;        // Assert&#10;        Assert.True(isBlocked);&#10;    }&#10;    &#10;    [Fact]&#10;    public void IsWholeDayBlocked_ShouldReturnFalse_WhenStartDateAndEndDateAreNotSpecifiedButDayOfWeekDoesNotMatch() {&#10;        // Arrange&#10;        var blockedTime = new BlockedTime(BlockedTimeType.Vacation);&#10;        var day1 = DateOnly.FromDateTime(DateTime.UtcNow);&#10;        var day2 = day1.AddDays(1);&#10;        var day3 = day1.AddDays(2);&#10;        blockedTime.RecurWeekly([day1.DayOfWeek, day2.DayOfWeek]);&#10;&#10;        // Act&#10;        var isBlocked = blockedTime.IsWholeDayBlocked(day3);&#10;&#10;        // Assert&#10;        Assert.False(isBlocked);&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ReturnsFalse_WhenDateIsBeforeStartDate() {&#10;        var dateToCheck = new DateOnly(2024, 6, 9);&#10;        var startTimeToCheck = new TimeOnly(8, 0);&#10;        var endTimeToCheck = new TimeOnly(9, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startDate: _date610, endDate: _date620);&#10;        Assert.False(blocked.IsBlocked(dateToCheck, startTimeToCheck, endTimeToCheck));&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ReturnsFalse_WhenDateIsAfterEndDate() {&#10;        var startTimeToCheck = new TimeOnly(8, 0);&#10;        var endTimeToCheck = new TimeOnly(9, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startDate: _date610, endDate: _date620);&#10;        Assert.False(blocked.IsBlocked(_date621, startTimeToCheck, endTimeToCheck));&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ReturnsFalse_WhenTimeDoesNotOverlap() {&#10;        var startTime = new TimeOnly(10, 0);&#10;        var endTime = new TimeOnly(12, 0);&#10;        var startTimeToCheck = new TimeOnly(8, 0);&#10;        var endTimeToCheck = new TimeOnly(9, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime, _date615, _date615);&#10;        Assert.False(blocked.IsBlocked(_date615, startTimeToCheck, endTimeToCheck));&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ReturnsTrue_WhenTimeOverlaps() {&#10;        var startTime = new TimeOnly(10, 0);&#10;        var endTime = new TimeOnly(12, 0);&#10;        var startTimeToCheck = new TimeOnly(11, 0);&#10;        var endTimeToCheck = new TimeOnly(13, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime, _date615, _date615);&#10;        Assert.True(blocked.IsBlocked(_date615, startTimeToCheck, endTimeToCheck));&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ReturnsTrue_ForDailyRecurrence() {&#10;        var startTime = new TimeOnly(8, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startTimeToCheck = new TimeOnly(9, 0);&#10;        var endTimeToCheck = new TimeOnly(10, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime, _date610, _date620);&#10;        Assert.True(blocked.IsBlocked(_date615, startTimeToCheck, endTimeToCheck));&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ReturnsFalse_ForWeeklyRecurrence_DayNotIncluded() {&#10;        var startTime = new TimeOnly(8, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startTimeToCheck = new TimeOnly(9, 0);&#10;        var endTimeToCheck = new TimeOnly(10, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime, _date610, _date620);&#10;        blocked.RecurWeekly([DayOfWeek.Monday]);&#10;        Assert.False(blocked.IsBlocked(new DateOnly(2024, 6, 12), startTimeToCheck, endTimeToCheck)); // Wednesday&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ReturnsTrue_ForWeeklyRecurrence_DayIncluded() {&#10;        var startTime = new TimeOnly(8, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startTimeToCheck = new TimeOnly(9, 0);&#10;        var endTimeToCheck = new TimeOnly(10, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime, _date610, _date620);&#10;        blocked.RecurWeekly([DayOfWeek.Wednesday]);&#10;        Assert.True(blocked.IsBlocked(new DateOnly(2024, 6, 12), startTimeToCheck, endTimeToCheck)); // Wednesday&#10;    }&#10;&#10;    [Fact]&#10;    public void IsBlocked_ThrowsArgumentException_WhenStartTimeIsAfterEndTime() {&#10;        var startTime = new TimeOnly(8, 0);&#10;        var endTime = new TimeOnly(17, 0);&#10;        var startTimeToCheck = new TimeOnly(12, 0);&#10;        var endTimeToCheck = new TimeOnly(10, 0);&#10;        var blocked = new BlockedTime(BlockedTimeType.AnnualLeave, startTime, endTime, _date610, _date620);&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt;&#10;            blocked.IsBlocked(new DateOnly(2024, 6, 12), startTimeToCheck, endTimeToCheck));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>